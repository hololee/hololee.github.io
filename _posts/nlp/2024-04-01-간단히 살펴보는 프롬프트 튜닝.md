---

title: 간단히 살펴보는 프롬프트 튜닝
date: 2024-04-01 20:23:00 +0900
categories: [nlp]
tags: [llm, prompt]
img_path: /

---

## 프롬프트 튜닝 사이클

1. 프롬프트 튜닝 사이클은 단순히 프롬프팅을 작성하는데 시간을 투자하는것이 아니다. **반복적으로 테스트를 진행해서** 프롬프트의 결과를 평가하며 개선해 나가는것이 중요하다.
2. test-driven 으로 접근하는것이 좋다. 우선 task의 목적을 명확히 해야한다. 다음으로 **평가를 위한 테스트 케이스를 구성**해야한다. 이때 특이한 edge-case를 뻬먹지 말고 넣어야 한다. 다음으로 해당 case에 대해 프롬프트를 다듬어가며 평가 결과를 바탕으로 개선해간다.
3. task에 대해서 목적 성능을 어느정도 달성하면 프롬프트를 단순화하거나, 작은 모델을 선택해서 테스트 해보고 문제가 없다면 조정한다. (마치 프루닝 작업을 프롬프트와 모델 선택에 하는 느낌)

## 프롬프트 팁

- 개인적으로 모든 프롬프트를 영어로 쓰고 마지막에 한국어로 결과를 출력해달라고 하는것이 효과가 좋았다.
- 내가 알고있는 배경지식을 언어모델도 알고 있다고 가정하지 말자. 나 또한 편향된 생각을 가지고 있기때문에 추상적인 내용보다 구체적인 지시사항을 작성하는것이 좋다.

1. **가능한 상세하게** 설명해서 지시한다.

    > **기존**: \
    개인정보를 제거해줘 \
    \
    **개선**: \
    개인정보를 제거해줘. \
    **이름, 이메일 등을 개인정보로 볼 수 있어. \
    개인정보가 아닌 데이터는 변경없이 그대로 출력해줘.**

    > **기존**: \
    다음 내용을 요약해줘 {내용}  \
    \
    **개선**: \
    **다음 내용을 요약해줘. 서론을 제외하고 요약 정보만 간단하게 출력해줘. {내용}**

2. 점 리스트나 숫자 리스트를 사용해서 필요한 지시사항을 나열한다.

    > **기존**: \
    포유류에 대해 설명해줘 \
    \
    **개선**: \
    포유류에 대해 설명해줘 \
    **&nbsp; 1. 우선 동물을 분류하는 방법에 대해 설명해줘. \
    &nbsp; 2. 분류 중 포유류의 특징을 다른 분류와 비교해서 설명해줘. \
    &nbsp; 3. 포유류에 속하는 동물 예시를 나열해줘.**

3. 정확한 목적을 지시한다.

    > **기존**: \
    세계에서 가장 유명한 개발자는 누구야? \
    \
    **개선**: \
    **세계에서 가장 유명한 개발자는 누구야? \
    물론 많은 후보가 있지만 한명만 선택해야한다고 할때 누구를 선택할거야?**

4. 예시를 이용해서 출력을 유도한다. 필요하다면 포멧을 예시로 들어서 출력을 유도한다.
(하지만 **예시를 다양하게 드는것이 중요**하다. 테스트 중에 반복적인 데이터를 예시로 사용했더니 해당 예시를 출력하는 경우가 발생하였다.)

    > **기존**: \
    세계에서 각장 유명한 개발자 이름을 알려줘. \
    \
    **개선**: \
    **세계에서 각장 유명한 개발자 이름을 알려줘. 예시는 다음과 같아. \
    \
    &nbsp; 정보: 세계에서 가장 유명한 개발자는 admin이야. \
    &nbsp; 응답: admin \
    \
    &nbsp; 정보: 세계에서 가장 유명한 개발자는 user야. \
    &nbsp; 응답:**

5. 역할을 부여하여 성능 향상과 말투, 표현 조정을 유도한다. 전문적인 작업 (수학 문제, 코드 작성 등), 특정 어조, 말투가 필요한 경우 등에서 효과가 좋다.

    > **기존**: \
    이차 방정식에 대해 설명해줘. \
    \
    **개선**: \
    **너는 초등학생을 가르치는 선생님이야. 학생에게 어려운 개념을 설명해줘야 해. \
    이차 방정식에 대해 설명해줘.**

6. 문제를 단계별로 나눠서 과정을 쉬운 단위로 나눠 설명하면 결과가 더 잘 나오게 된다. [CoT]

    > **기존**: \
    &nbsp; 문제: 빨간 주머니에 공이 3개, 파란 주머니에 공이 2개 있을때 빨간 주머니에서 공을 2개 빼고 파란 주머니에 1개를 넣은 후 파란 주머니에서 공을 하나 꺼낸다. \
    &nbsp; 답변: 빨간 주머니에 1개, 파란 주머니에 2개, 밖에 1개 공이 남아있다. \
    \
    &nbsp; 문제: 작은 바구니에 사과가 5개, 큰 바구니에 배가 3개 있을때 작은 바구니에서 3개를 빼고  바구니에 2개를 넣은 후 큰 바구니에서 1개를 뺀다. \
    &nbsp; 답변: \
    \
   > **개선**: \
    &nbsp; 문제: 빨간 주머니에 공이 3개, 파란 주머니에 공이 2개 있을때 빨간 주머니에서 공을 2개 빼고 파란 주머니에 1개를 넣은 후 파란 주머니에서 공을 하나 꺼낸다. \
    **&nbsp; 답변: 빨간 주머니에서 공을 2개 빼면 빨간 주머니에 1개, 파란주머니에 2개, 밖에 2개가 위치한다. 파란 주머니에 1개를 넣으면 빨깐 주머니에 1개, 파란 주머니에 3개, 밖에 1개 위치한다. 다음으로 파란 주머니에서 공을 하나 꺼내면 빨간 주머니에 1개, 파란주머니에 2개, 밖 위치한다.\
    \
    &nbsp; 문제: 작은 바구니에 사과가 5개, 큰 바구니에 배가 3개 있을때 작은 바구니에서 3개를 빼고 큰 바구니에 2개를 넣은 후 큰 바구니에서 1개를 뺀다. \
    &nbsp; 답변:**

7. 프롬프트 체이닝을 이용한다. 질문에 대한 답변을 다음 질문의 프롬프트로 넣어서 질문 디테일 강화, 검증, 요약등 다양한 응용을 수행할 수 있다. (실질적으로 LLM을 이용한 서비스 개발시 얼마나 체이닝을 디테일하게 구현하느냐에 따라 달라지는듯)

    > **기존**: \
    다음 글을 3개의 단락으로 나눠줘. 단락은 bullet point를 이용해서 간단히 출력해줘. \
    &nbsp; 문서:{docs} \
    &nbsp; 답변: \
    \
    **개선**: \
    [질문 1] 다음 글을 3개의 단락으로 나눠줘. 단락은 bullet point를 이용해서 간단히 출력해줘. \
    &nbsp; 문서:{docs} \
    &nbsp; 답변: \
    &nbsp; [답변 1] {answer} \
    \
    [질문 2] 다음 문서와 요약정보를 이용해서 요약집을 만들어줘. \
    &nbsp; 문서:{docs}, \
    &nbsp; 요약: {[답변 1]}

    > **기존**: \
    다음 문서를 짧게 요약해줘. 문서:{docs} 답변: \
    \
    **개선**: \
    **[질문 1] 다음 문서를 짧게 요약해줘. \
    &nbsp; 문서:{docs} \
    &nbsp; 답변: \
    &nbsp; [답변 1] {answer} \
    \
    [질문 2] 대화를 참고해서 추가 지시사항을 지키도록 수정해줘. \
    &nbsp; 대화: {[질문 1], [답변 1]}, \
    &nbsp; 지시사항: \
    &nbsp;&nbsp; bullet point로 나열. \
    &nbsp;&nbsp; 문법적인 오타를 수정.**

8. 응답 형태의 일부분을 미리 작성해서 응답의 구조를 제한한다. 원하는 형태로 답변을 하도록 유도할 수 있다.

    > **기존**: \
    다음 문서에서 이름과 이메일 주소를 json 형태로 출력해주세요. 
    \
    &nbsp; 문서: {docs} \
    \
    **개선**: \
    **다음 문서에서 이름과 이메일 주소를 json 형태로 출력해주세요. \
    &nbsp; 문서: {docs} \
    &nbsp; 답변: {**

9. 중요한 정보는 프롬프트의 앞쪽과 마지막 쪽에 배치시킨다. (프롬프트가 길어지면 중간에 있는 문장을 잘 인지하지 못하는 현상이 있음)

## 프롬프트 엔지니어링

> 아래의 기법들은 효과적인 문제 풀이를 보여주지만 비용이 많이 증가한다.
{: .prompt-info }

1. **Chain of Thoughts**: 복잡한 문제를 단계적으로 나눠서 퓨삿 프롬프트를 작성하면 논리적 문제를 더 잘 풀 수 있다!
2. **Self Consistency**: sampling(temperature scaling 등)을 통해서 여러 답변을 얻은 후 가장 빈도가 높은 답변을 선택하자!
3. **Tree of Thoughts**: 단계적 풀이에 tree구조를 적용한다! "가능한 다음 단계:"와 같은 문장으로 프롬프트를 마무리하여 다음 단계들을 추가적으로 뽑아낸다. 트리탐색 하듯 최종 결과를 결정한다.
4. **ReAct**: CoT 기법과 유사하지만 문제를 풀어가는 과정을 추론 -> 행동 -> 관측의 순서로 수행하며 행동 단계에서는 API를 통해서 실제로 검색한 결과를 프롬프팅에 이용한다.

실제 사내에서 사용할 RAG SQL 시스템을 POC 할때 한글을 이용한 프롬프트 튜닝보다는 영어를 이용한 튜닝을 진행하고 출력을 한글로 해달라고 요청하는 문장을 추가했다. 실제로도 한글보다는 영어로 튜닝을 했을때 결과가 잘 나오는 경향이 있었다.

## 주의 사항

1. 민감 정보 유출
2. Prompt Injection
3. Prompt Leaking

## Reference

- [엔트로픽 프롬프트 엔지니어링](https://docs.anthropic.com/claude/docs/prompt-engineering)
- [프롬프트 엔지니어링 가이드](https://www.promptingguide.ai/kr/techniques/prompt_chaining)
- [LangChain Use cases](https://python.langchain.com/docs/use_cases/sql/large_db#many-tables)
- [인공지능을 사용항는 인간을 위한 안내서 - 해봄](https://slashpage.com/haebom/hitchhiker)
- [프롬프트 엔지니어링 입문과정](https://learnprompting.org/ko/docs/intro)
- Lost in the Middle: How Language Models Use Long Contexts, F.Liu et al., 2023
